BFD GENERIC LIBRARY API:

#define BFD_VERSION 1
#define BFD_PACKET_LEN 24

#define VERS_SHIFT 5
#define DIAG_MASK 0x1f
#define STATE_MASK 0xC0
#define FLAGS_MASK 0x3f

/* RFC 5880 Section 4.1
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |Vers |  Diag   |Sta|P|F|C|A|D|M|  Detect Mult  |    Length     |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                       My Discriminator                        |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      Your Discriminator                       |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                    Desired Min TX Interval                    |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                   Required Min RX Interval                    |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                 Required Min Echo RX Interval                 |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ */
struct bfd_msg {
    uint8_t vers_diag;    /* Version and diagnostic. */
    uint8_t flags;        /* 2bit State field followed by flags. */
    uint8_t mult;         /* Fault detection multiplier. */
    uint8_t length;       /* Length of this BFD message. */
    __be32 my_disc;       /* My discriminator. */
    __be32 your_disc;     /* Your discriminator. */
    __be32 min_tx;        /* Desired minimum tx interval. */
    __be32 min_rx;        /* Required minimum rx interval. */
    __be32 min_rx_echo;   /* Required minimum echo rx interval. */
};

enum bfd_flags {
    FLAG_MULTIPOINT = 1 << 0,
    FLAG_DEMAND = 1 << 1,
    FLAG_AUTH = 1 << 2,
    FLAG_CTL = 1 << 3,
    FLAG_FINAL = 1 << 4,
    FLAG_POLL = 1 << 5
};

enum bfd_state {
    STATE_ADMIN_DOWN = 0 << 6,
    STATE_DOWN = 1 << 6,
    STATE_INIT = 2 << 6,
    STATE_UP = 3 << 6
};

enum bfd_diag {
    DIAG_NONE = 0,                /* No Diagnostic. */
    DIAG_EXPIRED = 1,             /* Control Detection Time Expired. */
    DIAG_ECHO_FAILED = 2,         /* Echo Function Failed. */
    DIAG_RMT_DOWN = 3,            /* Neighbor Signaled Session Down. */
    DIAG_FWD_RESET = 4,           /* Forwarding Plane Reset. */
    DIAG_PATH_DOWN = 5,           /* Path Down. */
    DIAG_CPATH_DOWN = 6,          /* Concatenated Path Down. */
    DIAG_ADMIN_DOWN = 7,          /* Administratively Down. */
    DIAG_RCPATH_DOWN = 8          /* Reverse Concatenated Path Down. */
};

enum bfd_error {
    BFD_PASS = 0,                 /* No error. */
    BFD_EINVAL = 1,               /* Invalid arguments. */
    BFD_EPOLL = 2,                /* bfd poll and final flags are both on. */
    BFD_EMSG = 3                  /* bfd control packet error. */
};

/* Used to configure a BFD session. */
struct bfd_setting {
    /* Local state variables. */
    uint32_t disc;                /* bfd.LocalDiscr. */
    uint8_t mult;                 /* bfd.DetectMult. */
    uint32_t min_tx;              /* bfd.DesiredMinTxInterval. */
    uint32_t min_rx;              /* bfd.RequiredMinRxInterval. */

    /* Open Vswitch specific settings. */
    bool cpath_down;              /* Set Concatenated Path Down. */
    bool forwarding_override;     /* Manual override of 'forwarding' status. */
    int forward_if_rx_interval;   /* How often to detect forward_if_rx. */
    int decay_min_rx;             /* bfd.min_rx is set to decay_min_rx when */
                                  /* in decay. */
};

/* BFD status. */
struct bfd_status {
    bool forwarding;              /* The liveness of bfd session. */
    uint8_t mult;                 /* bfd.DetectMult. */
    bool cpath_down;              /* If cpath_down enabled. */
    uint32_t tx_interval;         /* tx interval in use. */
    uint32_t rx_interval;         /* rx interval in use. */

    uint32_t local_min_tx;        /* bfd.DesiredMinTxInterval */
    uint32_t local_min_rx;        /* bfd.DesiredMinRxInterval*/
    enum bfd_flags local_flags;   /* Flags sent on messages. */
    enum bfd_state local_state;   /* bfd.SessionState. */
    enum bfd_diag local_diag;     /* bfd.LocalDiag. */

    uint32_t rmt_min_tx;          /* bfd.RemoteMinTxInterval */
    uint32_t rmt_min_rx;          /* bfd.RemoteMinRxInterval*/
    enum bfd_flags rmt_flags;     /* Flags last received. */
    enum bfd_state rmt_state;     /* bfd.RemoteSessionState. */
    enum bfd_diag rmt_diag;       /* Remote diagnostic. */

    uint64_t flap_count;          /* Flap count of forwarding. */
};

/* A BFD session.  Users are not permitted to directly access the variable
 * of this struct.  For BFD configuration, use the bfd_configure().  For
 * BFD status extraction, use the bfd_get_status(). */
struct bfd {
    /* Local state variables. */
    uint32_t disc;                /* bfd.LocalDiscr. */
    uint8_t mult;                 /* bfd.DetectMult. */
    enum bfd_state state;         /* bfd.SessionState. */
    enum bfd_diag diag;           /* bfd.LocalDiag. */
    enum bfd_flags flags;         /* Flags sent on messages. */
    uint32_t min_tx;              /* bfd.DesiredMinTxInterval. */
    uint32_t min_rx;              /* bfd.RequiredMinRxInterval. */
    uint32_t cfg_min_tx;          /* Configured minimum TX rate. */
    uint32_t cfg_min_rx;          /* Configured required minimum RX rate. */
    long long int detect_time;    /* RFC 5880 6.8.4 Detection time. */
    long long int last_tx;        /* Last TX time. */
    long long int next_tx;        /* Next TX time. */

    /* Remote side state variables. */
    uint32_t rmt_disc;            /* bfd.RemoteDiscr. */
    enum bfd_state rmt_state;     /* bfd.RemoteSessionState. */
    enum bfd_diag rmt_diag;       /* Remote diagnostic. */
    enum bfd_flags rmt_flags;     /* Flags last received. */
    long long int rmt_min_rx;     /* bfd.RemoteMinRxInterval. */
    long long int rmt_min_tx;     /* Remote minimum TX interval. */

    /* POLL sequence. */
    uint32_t poll_min_tx;         /* min_tx in POLL sequence. */
    uint32_t poll_min_rx;         /* min_rx in POLL sequence. */

    /* Open Vswitch specific features. */
    bool cpath_down;              /* Set Concatenated Path Down. */

    int forwarding_override;      /* Manual override of 'forwarding' status. */

    /* Equivalent to bfd demand mode. */
    bool last_forwarding;         /* Last calculation of forwarding flag. */
    int forward_if_rx_interval;   /* How often to detect forward_if_rx. */
    long long int forward_if_rx_detect_time;
    bool forward_if_rx_data;      /* Data packet received in last interval. */

    /* BFD decay feature is for reducing the */
    bool in_decay;                /* True when bfd is in decay. */
    int decay_min_rx;             /* bfd.min_rx is set to decay_min_rx when */
                                  /* in decay. */
    long long int decay_detect_time; /* Next decay detect time. */
    uint32_t decay_rx_count;      /* Count of data packets received. */

    uint64_t flap_count;          /* Counts bfd forwarding flaps. */
};

/* Configures bfd using the 'setting'.  Returns 0 if successful, a positive
 * error number otherwise. */
enum bfd_error bfd_configure(struct bfd_session *, const struct bfd_setting *);

/* Returns the wakeup time of the bfd session. */
long long int bfd_wait(const struct bfd *);

/* Updates the bfd sessions status.  Checks decay and forward_if_rx.
 * Initiates the POLL sequence if needed. */
void bfd_run(struct bfd *, long long int now);

/* Queries the 'bfd''s status, the function will fill in the
 * 'bfd_status'. */
void bfd_get_status(const struct bfd *, struct bfd_status *)

/* Returns true if the interface on which bfd is running may be used to
 * forward traffic according to the BFD session state.  'now' is the
 * current time in milliseconds. */
bool bfd_forwarding(const struct bfd *, long long int now);

/* Sets the corresponding flags to indicate that packet
 * is received from this monitored interface. */
void bfd_account_rx(struct bfd *bfd, uint32_t n_pkt);


/* For send/recv bfd control packets. */
/* Returns true if the bfd control packet should be sent for this bfd
 * session.  e.g. tx timeout or POLL flag is on.  'now' is the current
 * time in milliseconds. */
bool bfd_should_send_packet(const struct bfd *, long long int now);

/* Constructs the bfd packet in payload.  This function assumes that the
 * payload is properly aligned.  'now' is the current time in milliseconds. */
enum bfd_error bfd_put_packet(struct bfd *, void *p, size_t len,
                              long long int now);

/* Given the packet header entries, check if the packet is bfd control
 * packet. */
bool bfd_should_process_packet(const __be16 eth_type, const uint8_t ip_proto,
                               const __be16 udp_src);

/* Processes the bfd control packet in payload 'p'.  The payload length is
 * provided.  'now' is the current time in milliseoncds. */
enum bfd_error bfd_process_packet(struct bfd *, void *p, size_t len,
                                  long long int now);


/* Helpers*/
/* Converts the bfd error code to string. */
char * bfd_error_to_str(enum bfd_error error);

/* Converts the bfd flags to string. */
const char * bfd_flag_to_str(enum bfd_flags flags);

/* Converts the bfd state code to string. */
const char * bfd_state_to_str(enum bfd_state state);

/* Converts the bfd diag to string. */
const char * bfd_diag_to_str(enum bfd_diag diag);



/* NOTE:
 *
 * - decay is checked every decay_min_rx time.  so user must guarantee that
 *   the bfd_account_rx() is called at least every 'decay_min_rx' amount of
 *   time.
 *
 * - the boolean variable 'forwarding_if_rx' is changed to the int variable
 *   'forward_if_rx_interval'.  and the 'forward_if_rx_detect_time' is
 *   incremented by 'forward_if_rx_interval' each time.  user must guarantee
 *   that bfd_account_rx() is called at least every 'forward_if_rx_interval'
 *   amount of time.
 *
 * - the implementation puts the update of 'decay', 'forward_if_rx' and
 *   'flap_count' in bfd_run().
 *
 * - need to select a better random number generator function, since 'rand'
 *   is not suitable for multithreading.
 *
 * - user should use mutex to synchronize the multi-access to bfd functions.
 *
 *
 */