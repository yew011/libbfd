BFD MONITOR API:

/*
 * Monitor Module
 * --------------
 *
 * This module abstracts the tunnel monitoring logic and employs max heap
 * to order the monitoring session.  Design features are listed below:
 *
 * - Since Open Vswitch already has a max heap implimentation, the monitor
 *   module will use it directly.  Work is being done to make it generic.
 *
 * - To use the monitor, user must pass in an identifier (void *ptr) which
 *   can be used to dereference the monitoring session (e.g. bfd/cfm).  For
 *   example, 'ptr' can be the pointer to the actual monitored interface
 *   which contains reference to bfd/cfm object.  The API functions will
 *   return the 'ptr' of the timed out session, so user can get bfd/cfm
 *   reference from 'ptr' and execute the sending+manage loop.  Please
 *   refer to the example pseudocode below.
 *
 * - The module is not thread-safe and must be protected by a global mutex.
 *
 *
 * Example Pseudocode
 * ------------------
 *     // sending+manage loop in Open Vswitch
 *
 *     mutex_lock(global_mutex)
 *     port = monitor_get_timedout_session(current_time_milliseconds);
 *     while(port) {
 *
 *         if (port->bfd) {
 *             if (bfd_should_send_packet(port->bfd)) {
 *                 bfd_put_packet(port->bfd, pkt);
 *                 send_packet(port, pkt);
 *             }
 *             bfd_run(port->bfd);
 *             bfd_wait(port->bfd);
 *         }
 *
 *         if (port->cfm) {
 *             if (cfm_should_send_packet(port->cfm)) {
 *                 cfm_put_packet(port->cfm, pkt);
 *                 send_packet(port, pkt);
 *             }
 *             cfm_run(port->cfm);
 *             cfm_wait(port->cfm);
 *         }
 *
 *         monitor_update_session_timeout(port, MIN(bfd_wait(port->bfd),
 *                                        cfm_wait(port->cfm)));
 *         port = monitor_get_timedout_session(current_time_milliseconds);
 *     }
 *     mutex_unlock(global_mutex)
 *
 * */

/* API Exposed To User. */

/* Returns true if the 'monitor_hmap' is not empty. */
bool monitor_has_session(void);

/* Creates a 'struct mport' for 'ptr' and registers the mport to the
 * 'monitor_heap' and 'monitor_hmap'. */
void monitor_register_session(void *ptr);

/* Unregisters the 'struct mport' that contains the 'ptr' from
 * 'monitor_heap' and 'monitor_hmap', and deletes the 'struct mport'. */
void monitor_unregister_session(void *ptr);

/* Given the current time 'now', returns the '__ptr' of the 'struct mport'
 * of top-of-heap session, if 'now' is greater than the timeout of the
 * top-of-heap session.  Otherwise, returns NULL.  */
const void * monitor_get_timedout_session(long long int now);

/* Updates the priority of the heap node of the 'struct mport' which contains
 * 'ptr' based on the next wakeup time 'next'. */
int monitor_update_session_timeout(const void *ptr, long long int next);

/* Returns the timeout in milliseconds of the session of top-of-heap
 * mport. */
long long int monitor_next_timeout(void);